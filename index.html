<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="cms.css" />

<script>
const DEV = true;
const GH_APP_ID = '1a620656396aa0d6b5c2';
</script>

<p>Drag a config file (with collections) on here. And after choosing a collection, a markdown/content file. OR:</p>

<p id="gh-authing">Finishing up Github authentication...</p>

<div id="gh-auth">
	<button onclick="github.start()">Authenticate with Github</button>
</div>

<form id="config">
	Config:
	<select name="repo">
		<option>rudiedirkx2/netlify1-hugo</option>
		<option>rudiedirkx2/netlify2-jekyll</option>
		<option>rudiedirkx/dipcorp2:master</option>
		<option>rudiedirkx2/tugboat-sqlite</option>
		<option>Loading...</option>
	</select>
	<select name="provider">
		<option>Hugo on Netlify</option>
		<option>Jekyll on Netlify</option>
		<option>Github pages</option>
	</select>
	<button>Load</button>
</form>

<form id="page">
	<select></select>
	<button>Load</button>
	|
	Open: <span id="create-buttons"></span>
</form>

<form id="content">
	<div></div>
	<button>Save</button>
</form>

<script src="gh-auth.js"></script>
<script src="cms.js"></script>
<script src="providers.js"></script>
<script async defer src="https://unpkg.com/js-yaml@3.12.0/dist/js-yaml.js"></script>
<script>
const github = new GithubAuth(GH_APP_ID);

window.addEventListener('load', e => {
	github.process() && !DEV && loadRepos();
});

function parseContent(text) {
	const frontMatter = text.match(/^---[\r\n]+([\w\W]+?)---([\r\n]|$)/);
	if (!frontMatter) throw new Error("Can't extract front matter from text:\n" + text);

	const body = text.substr(frontMatter[0].length).trim();
	return {body, ...parseFrontMatterYaml(frontMatter[1])};
}

function parseFrontMatterYaml(text) {
	return jsyaml.load(text, {schema: jsyaml.JSON_SCHEMA});
}

async function loadConfigFromFile(file) {
	const text = await file.text();
	return loadConfigFromText(text);
}

async function loadContentFromFile(file) {
	const text = await file.text();
	return loadContentFromText(text);
}

function parseConfigYaml(text) {
	return jsyaml.load(text, {schema: jsyaml.JSON_SCHEMA});
}

function loadRepos() {
	github.get('https://api.github.com/user/repos').then(rsp => {
		const sel = elConfigForm.querySelector('select');
			sel.innerHTML = '';
			rsp.forEach(repo => {
				const el = document.createElement('option');
				el.value = repo.full_name + ':' + repo.default_branch;
				el.textContent = repo.full_name;
				sel.append(el);
			});
		});
}

// ==== //

const randomChar = () => String.fromCodePoint(65 + parseInt(26 * Math.random()));

function createFieldset(fields, title) {
	const fs = document.createElement('fieldset');

	if (title) {
		const leg = document.createElement('legend');
		leg.textContent = title;
		fs.append(leg);
	}
	else {
		fs.classList.add('structure');
	}

	for (let fname in fields) {
		const field = fields[fname];
		const row = document.createElement('fieldset');
		row._field = field;
		row.classList.add('widget');
		row.dataset.widget = field.widget;
		row.dataset.name = fname;
		fs.append(row);
		const leg = document.createElement('legend');
		leg.textContent = field.label;
		row.append(leg);
		row.append(createWidget(field));
	}
	return fs;
}

function createWidget(field) {
	const handler = WIDGETS[field.widget];
	if (handler) {
		return handler.create(field);
	}

	return document.createTextNode(' ' + field.widget);
}

function setFieldsetValues(fs, values) {
	for (let el of fs.querySelectorAll(':scope > fieldset[data-widget][data-name]')) {
		const handler = WIDGETS[el.dataset.widget];
		handler.setValue(el, el._field, values[el.dataset.name]);
	}
}

function getFieldsetValues(fs) {
	const values = {};
	for (let el of fs.querySelectorAll(':scope > fieldset[data-widget][data-name]')) {
		const handler = WIDGETS[el.dataset.widget];
		values[el.dataset.name] = handler.getValue(el, el._field);
	}
	return values;
}

// ==== //

var g_collections = {};
var g_collection = '';

async function loadConfigFromText(text) {
	const config = parseConfigYaml(text);
	g_collections = extractCollections(config);
	g_collection = '';
	elContentForm.innerHTML = '';
	createButtons();
	return g_collections;
}

async function loadContentFromText(text) {
	const values = parseContent(text);
	const fs = elContentForm.querySelector('fieldset');
	fs && setFieldsetValues(fs, values || {});
	return values;
}

// ==== //

const elCreateButtons = document.querySelector('#create-buttons');
const elContentForm = document.querySelector('form#content > div');
const elConfigForm = document.querySelector('form#config');
const elPageForm = document.querySelector('form#page');

var cmsUi = new CmsUI();
var cms;

elConfigForm.addEventListener('submit', function(e) {
	e.preventDefault();
	const repo = this.elements.repo.value;
	const provider = new PROVIDERS[this.elements.provider.value];

	cms = new CmsContext(cmsUi, provider);

	const pieces = repo.split(':');
	const url = `https://api.github.com/repos/${pieces[0]}/git/trees/${pieces[1]||'master'}?recursive=1`;
	const finder = names => file => names.includes(file.path);
	github.get(url).then(rsp => {
		if (!rsp.tree) throw new Error(`Can't find files in repo '${repo}':\n` + JSON.stringify(rsp, null, '  '));

		const file = provider.findConfigFile(rsp.tree);
		if (!file) throw new Error(`Can't find config file in repo '${repo}'\n` + JSON.stringify(rsp.tree, null, '  '));

		// Load collections
		github.get(file.url).then(rsp => {
			const text = github.b64decode(rsp.content);
			const config = parseConfigYaml(text);
			cms.loadCollections(config).then(x => console.log('config from github', x));
		});

		// Load pages
		cms.loadPages(rsp.tree).then(x => console.log('pages from github', x));
	});
});

elPageForm.addEventListener('submit', e => {
	e.preventDefault();
	const select = elPageForm.querySelector('select');
	const url = select.value;
	const path = select.options[select.selectedIndex].label;

	const collection = cms.findCollectionFromPath(path);
	collection && cms.loadContentForm(collection);

	github.get(url).then(rsp => {
		const text = github.b64decode(rsp.content);
		loadContentFromText(text).then(x => console.log('content from github', x));
	});
});

elCreateButtons.addEventListener('click', e => {
	const btn = e.target.closest('button');
	if (btn && btn.dataset.collection) {
		e.preventDefault();
		cms.loadContentForm(btn.dataset.collection);
	}
});

elContentForm.closest('form').addEventListener('submit', e => {
	e.preventDefault();
	const fs = elContentForm.querySelector('fieldset');
	const values = getFieldsetValues(fs);
	console.log(values);
	// @todo Keep original values that are not in the form, like `layout`
	const {body, ...fm} = values;
	const md = `---\n${jsyaml.dump(fm).trim()}\n---\n\n${body}\n`
	console.log(md);
});

document.addEventListener('dragover', e => {
	e.preventDefault();
});
document.addEventListener('drop', async e => {
	e.preventDefault();
	const file = e.dataTransfer.files[0];

	if (file.name.match(/\.ya?ml$/i)) {
		return loadConfigFromFile(file).then(x => console.log('config from file drop', x));
	}

	if (file.name.match(/\.(md|html)$/i) && g_collection) {
		return loadContentFromFile(file).then(x => console.log('content from file drop', x));
	}
});
</script>
