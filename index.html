<style>
fieldset.structure {
	border: 0;
	padding: 0;
	margin: 0;
}
fieldset, button {
	margin: 1em 0;
}

.widget[data-widget="hidden"] {
	display: none;
}

input[type="text"],
textarea {
	width: 700px;
}
</style>

<!-- <p>Drag a config file (with collections) on here. And after choosing a collection, a markdown/content file.</p> -->

<form id="config">
	Config:
	<select>
		<option>rudiedirkx/dipcorp2/master</option>
		<option>rudiedirkx2/netlify1-hugo</option>
		<option>rudiedirkx2/netlify2-jekyll</option>
	</select>
	<button>Load</button>
</form>

<form id="page">
	<select></select>
	<button>Load</button>
	|
	Open: <span id="create-buttons"></span>
</form>

<form id="content">
	<div></div>
	<button>Save</button>
</form>

<script src="https://unpkg.com/js-yaml@3.12.0/dist/js-yaml.js"></script>
<script>
var TOKEN = localStorage.staticPagesCmsToken || 'x';
const get = url => fetch(new Request(url, {headers: {"Authorization": `token ${TOKEN}`}}));

// Load config.yml for fields
// Load post md file to edit, or
// Create new collection item

function parseContent(text) {
	const frontMatter = text.match(/^---[\r\n]+([\w\W]+?)---([\r\n]|$)/);
	if (!frontMatter) return {};

	const body = text.substr(frontMatter[0].length).trim();
	return {body, ...parseFrontMatterYaml(frontMatter[1])};
}

function parseFrontMatterYaml(text) {
	return jsyaml.load(text, {schema: jsyaml.JSON_SCHEMA});
}

async function loadConfigFromFile(file) {
	const text = await file.text();
	return loadConfigFromText(text);
}

async function loadContentFromFile(file) {
	const text = await file.text();
	return loadContentFromText(text);
}

function parseConfigYaml(text) {
	return jsyaml.load(text, {schema: jsyaml.JSON_SCHEMA});
}

function extractCollections(config) {
	if (config.collections && config.collections[0] && config.collections[0].fields && config.collections[0].fields[0]) {
		return extractCollectionsArray(config.collections);
	}

	if (config.collections && config.collections.length == null) {
		const key = Object.keys(config.collections)[0];
		if (config.collections[key].fields && config.collections[key].fields.length == null) {
			return extractCollectionsObject(config.collections);
		}
	}

	return {};
}

function extractCollectionsObject(object) {
	for (let cname in object) {
		const collection = object[cname];
		collection.label = collection.label || collection.name || cname;
		extractFieldsObject(collection.fields);
		ensureCollectionBody(collection.fields);
	}

	return object;
}

function extractFieldsObject(object) {
	for (let fname in object) {
		const field = object[fname];
		field.widget = field.widget || field.type || 'string';
		delete field.type;
		field.label = field.label || field.name || fname;
		delete field.name;
		field.required = field.required == null ? true : field.required;
		field.fields && extractFieldsObject(field.fields);
	}

	return object;
}

function extractCollectionsArray(array) {
	const collections = {};
	for (let collection of array) {
		if (collection.fields) {
			collections[collection.name] = {
				label: collection.label,
				fields: extractFieldsArray(collection.fields),
			};
			ensureCollectionBody(collections[collection.name].fields);
		}
		else if (collection.files) {
			for (let file of collection.files) {
				const cname = collection.name + ':' + file.name;
				collections[cname] = {
					label: file.label || (collection.label + ' - ' + file.name),
					fields: extractFieldsArray(file.fields),
				};
				ensureCollectionBody(collections[cname].fields);
			}
		}
	}

	return collections;
}

function extractFieldsArray(array) {
	const fields = {};
	for (let field of array) {
		fields[field.name] = field;
		if (field.fields) {
			field.fields = extractFieldsArray(field.fields);
		}
		else if (field.field && field.field.name) {
			field.fields = {[field.field.name]: field.field};
			delete field.field;
		}
	}

	return fields;
}

function ensureCollectionBody(fields) {
	if (!fields.body) {
		fields.body = {widget: 'hidden', label: '~body~'};
	}
}

// ==== //

const randomChar = () => String.fromCodePoint(65 + parseInt(26 * Math.random()));

const getInputValue = (el, props) => el.querySelector('input, select, textarea').value;
const setInputValue = (el, props, val) => el.querySelector('input, select, textarea').value = val == null ? '' : val;
const WIDGETS = {
	hidden: {
		create(props) {
			return document.createElement('textarea');
		},
		setValue : setInputValue,
		getValue: getInputValue,
	},
	string: {
		create(props) {
			return createInput();
		},
		setValue : setInputValue,
		getValue: getInputValue,
	},
	date: {
		create(props) {
			return createInput('date');
		},
		setValue : setInputValue,
		getValue: getInputValue,
	},
	datetime: {
		create(props) {
			return createInput('datetime');
		},
		setValue : setInputValue,
		getValue: getInputValue,
	},
	number: {
		create(props) {
			return createInput('number');
		},
		setValue : setInputValue,
		getValue: getInputValue,
	},
	file: {
		create(props) {
			return createInput('text');
		},
		setValue: setInputValue,
		getValue: getInputValue,
	},
	select: {
		create(props) {
			const sel = document.createElement('select');
			[{value: '', label: '--'}, ...(props.options || [])].forEach(opt => {
				const el = document.createElement('option');
				el.value = opt.value || opt.label;
				el.textContent = opt.label || opt.value;
				sel.append(el);
			});
			return sel;
		},
		setValue: setInputValue,
		getValue: getInputValue,
	},
	text: {
		create(props) {
			const el = document.createElement('textarea');
			el.value = randomChar();
			return el;
		},
		setValue: setInputValue,
		getValue: getInputValue,
	},
	list: {
		create(props) {
			return createFieldset(props.fields, 'Item 1');
		},
		setValue(el, props, value) {
			if (!value || !value.length) return;

			el.querySelectorAll(':scope > fieldset').forEach(fs => fs.remove());

			const L = value.length || 1;
			for ( let n = 0; n < L; n++ ) {
				const fs = createFieldset(props.fields, `Item ${n+1}`);
				el.append(fs);
				setFieldsetValues(fs, value[n]);
			}
		},
		getValue(el, props) {
			const items = Array.from(el.querySelectorAll(':scope > fieldset'));
			return items.map(fs => getFieldsetValues(fs));
		},
	},
	object: {
		create(props) {
			return createFieldset(props.fields);
		},
		setValue(el, props, value) {
			setFieldsetValues(el.querySelector('fieldset'), value || {});
		},
		getValue(el, props) {
			return getFieldsetValues(el.querySelector('fieldset'));
		},
	},
};
WIDGETS.markdown = WIDGETS.text;
WIDGETS.image = WIDGETS.file;

function createButtons() {
	elCreateButtons.innerHTML = '';
	for (let cname in g_collections) {
		const btn = document.createElement('button');
		btn.textContent = g_collections[cname].label;
		btn.dataset.collection = cname;
		elCreateButtons.append(btn);
		elCreateButtons.append(' ');
	}
}

function createForm(cname) {
	elContentForm.innerHTML = '';
	elContentForm.append(createFieldset(g_collections[cname].fields, g_collections[cname].label));
	g_collection = cname;
}

function createFieldset(fields, title) {
	const fs = document.createElement('fieldset');

	if (title) {
		const leg = document.createElement('legend');
		leg.textContent = title;
		fs.append(leg);
	}
	else {
		fs.classList.add('structure');
	}

	for (let fname in fields) {
		const field = fields[fname];
		const row = document.createElement('fieldset');
		row._field = field;
		row.classList.add('widget');
		row.dataset.widget = field.widget;
		row.dataset.name = fname;
		fs.append(row);
		const leg = document.createElement('legend');
		leg.textContent = field.label;
		row.append(leg);
		row.append(createWidget(field));
	}
	return fs;
}

function createWidget(field) {
	const handler = WIDGETS[field.widget];
	if (handler) {
		return handler.create(field);
	}

	return document.createTextNode(' ' + field.widget);
}

function createInput(type) {
	const el = document.createElement('input');
	el.type = type || 'text';
	if (el.type != 'file') {
		el.value = randomChar();
	}
	return el;
}

function setFieldsetValues(fs, values) {
	for (let el of fs.querySelectorAll(':scope > fieldset[data-widget][data-name]')) {
		const handler = WIDGETS[el.dataset.widget];
		handler.setValue(el, el._field, values[el.dataset.name]);
	}
}

function getFieldsetValues(fs) {
	const values = {};
	for (let el of fs.querySelectorAll(':scope > fieldset[data-widget][data-name]')) {
		const handler = WIDGETS[el.dataset.widget];
		values[el.dataset.name] = handler.getValue(el, el._field);
	}
	return values;
}

// ==== //

var g_collections = {};
var g_collection = '';

async function loadConfigFromText(text) {
	const config = parseConfigYaml(text);
	g_collections = extractCollections(config);
	g_collection = '';
	elContentForm.innerHTML = '';
	createButtons();
	return g_collections;
}

async function loadContentFromText(text) {
	const values = parseContent(text);
	const fs = elContentForm.querySelector('fieldset');
	setFieldsetValues(fs, values);
	return values;
}

// ==== //

const elCreateButtons = document.querySelector('#create-buttons');
const elContentForm = document.querySelector('form#content > div');
const elConfigForm = document.querySelector('form#config');
const elPageForm = document.querySelector('form#page');

elConfigForm.addEventListener('submit', e => {
	e.preventDefault();
	const m = elConfigForm.querySelector('input, select').value.match(/^([^\/]+\/[^\/]+)(?:(\/[^\/]+))?$/);
	const url = `https://api.github.com/repos/${m[1]}/git/trees/${m[2]||'master'}?recursive=1`;
	const finder = names => file => names.includes(file.path);
	get(url).then(rsp => rsp.json()).then(rsp => {
		const cfgFile = null ||
			rsp.tree.find(finder(['admin/config.yml', 'site/static/admin/config.yml'])) ||
			rsp.tree.find(finder(['_config.yml']));
		// Extract config
		get(cfgFile.url).then(rsp => rsp.json()).then(rsp => {
			loadConfigFromText(atob(rsp.content)).then(x => console.log('config from github', x));
		});
		// Load pages
		const pages = rsp.tree.filter(file => file.path.match(/\.(md|html)$/i) && !file.path.match(/(^|\/)_?layouts\//));
		const select = elPageForm.querySelector('select');
		select.innerHTML = pages.map(file => `<option value="${file.url}">${file.path}</option>`).join('');
	});
});

elPageForm.addEventListener('submit', e => {
	e.preventDefault();
	const url = elPageForm.querySelector('select').value;
	get(url).then(rsp => rsp.json()).then(rsp => {
		const text = decodeURIComponent(escape(atob(rsp.content.trim())));
		loadContentFromText(text).then(x => console.log('content from github', x));
	});
});

elCreateButtons.addEventListener('click', e => {
	const btn = e.target.closest('button');
	if (btn && btn.dataset.collection) {
		e.preventDefault();
		createForm(btn.dataset.collection);
	}
});

elContentForm.closest('form').addEventListener('submit', e => {
	e.preventDefault();
	const fs = elContentForm.querySelector('fieldset');
	const values = getFieldsetValues(fs);
	console.log(values);
	console.log(jsyaml.dump(values));
});

document.addEventListener('dragover', e => {
	e.preventDefault();
});
document.addEventListener('drop', async e => {
	e.preventDefault();
	const file = e.dataTransfer.files[0];

	if (file.name.match(/\.ya?ml$/i)) {
		return loadConfigFromFile(file).then(x => console.log('config from file drop', x));
	}

	if (file.name.match(/\.(md|html)$/i) && g_collection) {
		return loadContentFromFile(file).then(x => console.log('content from file drop', x));
	}
});
</script>
